{"meta":{"title":"兮xiyue曰","subtitle":null,"description":null,"author":"xiyue","url":"http://xiiyue.gitee.io","root":"/"},"pages":[{"title":"archives","date":"2019-09-23T12:49:21.000Z","updated":"2019-09-26T12:31:57.469Z","comments":true,"path":"archives/index.html","permalink":"http://xiiyue.gitee.io/archives/index.html","excerpt":"","text":""},{"title":"about","date":"2019-09-25T11:54:31.000Z","updated":"2019-10-27T08:56:19.740Z","comments":true,"path":"about/index.html","permalink":"http://xiiyue.gitee.io/about/index.html","excerpt":"","text":"没啥"},{"title":"categories","date":"2019-09-23T12:24:30.000Z","updated":"2019-10-26T15:28:28.958Z","comments":false,"path":"categories/index.html","permalink":"http://xiiyue.gitee.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-09-27T09:57:54.000Z","updated":"2019-10-26T15:27:59.084Z","comments":false,"path":"tags/index.html","permalink":"http://xiiyue.gitee.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"网易云音乐解锁","slug":"20200518_网易云音乐解锁","date":"2020-05-18T08:29:09.000Z","updated":"2020-05-18T11:58:33.191Z","comments":true,"path":"2020/05/18/20200518_网易云音乐解锁/","link":"","permalink":"http://xiiyue.gitee.io/2020/05/18/20200518_网易云音乐解锁/","excerpt":"UnblockNeteaseMusicGitHub上有一个UnblockNeteaseMusic项目，用于解锁网易云音乐客户端变灰歌曲。项目地址在https://github.com/nondanee/UnblockNeteaseMusic。","text":"UnblockNeteaseMusicGitHub上有一个UnblockNeteaseMusic项目，用于解锁网易云音乐客户端变灰歌曲。项目地址在https://github.com/nondanee/UnblockNeteaseMusic。 配置1.下载下载项目的源代码，然后解压出来。为了方便寻找，我解压到网易云音乐的安装位置。 2.本机配置运行cmd，转到源代码目录下。 输入指令 node app.js -p 4000 -f 59.111.181.60 ‘4000’表示该服务开启的端口，默认是8080，这个端口有其他软件占用了，所以我随便选了4000 ‘59.111.181.60’表示网易云服务器IP，用指令ping music.163.com获得。 指令需要安装nodejs。运行后配置完成。 pc端node指令运行后，cmd窗口不要关。打开网易云音乐客户端，设置—&gt;工具—&gt;自定义代理—&gt;HTTP—&gt;服务器填127.0.0.1—&gt;端口填4000（与指令中一致） 确认后会重启客户端，然后灰色音乐会解锁。 安卓端node指令运行后，cmd窗口不要关。首先要获取本机的ip。在cmd中通过命令ipconfig获得，ipv4的那一项。手机与pc在同一网络下，手机选择连接的WiFi，设置该WiFi，代理项选手动，服务器填ipconfig获得的本机ip，端口填4000（与node指令中一致）。然后就能使用了，用完要把WiFi设置改回来。","categories":[{"name":"软件","slug":"软件","permalink":"http://xiiyue.gitee.io/categories/软件/"}],"tags":[{"name":"网易云","slug":"网易云","permalink":"http://xiiyue.gitee.io/tags/网易云/"}]},{"title":"WorldEdit的使用","slug":"WorldEdit的使用","date":"2020-02-21T08:47:50.000Z","updated":"2020-05-12T02:31:40.202Z","comments":true,"path":"2020/02/21/WorldEdit的使用/","link":"","permalink":"http://xiiyue.gitee.io/2020/02/21/WorldEdit的使用/","excerpt":"选区选点小木斧左键选择第一个点，右键选择第二个点。 玩家空中并没有方块供小木斧敲。 //pos1 确定第一个点//pos2 确定第二个点将玩家所在地的位置作为选择点，且是脚所在的方块，不是脚踩的方块。 另外，该指令后面可以加坐标精确指定，//pos1 x,y,z。","text":"选区选点小木斧左键选择第一个点，右键选择第二个点。 玩家空中并没有方块供小木斧敲。 //pos1 确定第一个点//pos2 确定第二个点将玩家所在地的位置作为选择点，且是脚所在的方块，不是脚踩的方块。 另外，该指令后面可以加坐标精确指定，//pos1 x,y,z。 远程人不想动，希望远程选区。先看向要指定的点，要用指针指向方块。 //hpos1 确定第一个点//hpos2 确定第二个点。 选区调整扩展已经有了选区，但没包全 //expand &lt;格数&gt; [方向] 正面扩展 ‘&lt;&gt;’表示必需的参数；’[]’表示可选参数、方向参数：E、S、W、N、U、D，不填则是玩家看向的方向。当方向选定后，一个长方体在这个方向上有两个面，为了方便区分，我用正面和背面描述。 ----------------&gt;选定的方向 %%%%%%%%%%%%%%%% % %背面 % 选区截面 % 正面 % % %%%%%%%%%%%%%%%% //expand &lt;格数&gt; &lt;格数&gt; [方向] 正面、背面扩展 第一个参数是正面扩展的格数，第一个参数是背面扩展的格数 //expand vert 上下扩展到世界最高最低 缩减与expand相反，注意缩减的位置 //contract &lt;格数&gt; [方向] 背面缩减//expand &lt;格数&gt; &lt;格数&gt; [方向] 背面、正面缩减 全扩缩//outset &lt;格数&gt; 全方向扩展//inset &lt;格数&gt; 全方向缩减 另，有两个flag，放在指令后，参数前。-h 仅水平方向-v 仅垂直方向如：//outset -h 10 全水平方向扩展10格 移动选区整体将选择区域移动，不影响区域内的内容。//shift &lt;格数&gt; [方向] 选区编辑撤销//undo [次数] 不填次数则为1 反撤销//redo [次数] 不填次数则为1 填充//set &lt;方块&gt; 区域内全部填充指定方块 替换//replace &lt;%方块&gt; [@方块]如果没有第二个参数，将区域内所有方块替换为’%方块’，空气不变有第二个参数，则用’@方块’替换区域内的’%方块’。 另，缩写指令//rep或//re 移动//move &lt;格数&gt; [方向]移动选区内的方块，选区位置不变，且移动后，原位置变为空气。 //move &lt;格数&gt; &lt;方向&gt; [留存方块]由于要填留存方块参数，前面的方向参数必须填，可以用me表示玩家面向方向。移动后，原位置全部空间变为留存方块。 另，有flag。-s 选区和方块一起移动 结构线性阵列//stack &lt;次数&gt; [方向]向指定方向，复制整个选区，选区位置不会变。 另，有flag。-a 忽略空气方块 墙//walls &lt;方块&gt;选区边缘生成一格宽的墙，上下不封。 壳//faces &lt;方块&gt;选区边缘生成一格宽的壳，上下左右前后六面封死。 中心点//center &lt;方块&gt;选区的正中心生成方块 掏空//hollow &lt;方块&gt;以选区内的所有结构为目标，掏空留壳。比如选区内有一个实心的玻璃球和一个实心的石头正方体，掏空后留下一个玻璃球壳和一个石头正方体壳。 加盖//overlay &lt;方块&gt;从正上方俯视选区，俯视图中的方块的上方加上指定方块。 球体//sphere &lt;方块&gt; &lt;半径&gt;生成实心球体，中心在玩家所站的方块。 //hsphere &lt;方块&gt; &lt;半径&gt;生成空心球体。 //sphere &lt;方块&gt; &lt;南北半径&gt;,[上下半径],[东西半径]生成实心椭球体。 //hsphere &lt;方块&gt; &lt;南北半径&gt;,[上下半径],[东西半径]生成空心椭球体。 生成位置也可手动选择： /toggleplace切换生成位置的模式，模式1：玩家脚所在方块；模式2：第一选择方块（即pos1位置） 圆柱//cyl &lt;方块&gt; &lt;半径&gt; &lt;高度&gt;生成实心圆柱，玩家脚在圆柱底面中心。 //hcyl &lt;方块&gt; &lt;半径&gt; &lt;高度&gt;生成空心圆柱。 //cyl &lt;方块&gt; &lt;东西半径&gt;,[南北半径] &lt;高度&gt;生成实心椭圆柱。 //hcyl &lt;方块&gt; &lt;东西半径&gt;,[南北半径] &lt;高度&gt;生成空心椭圆柱。 金字塔//pyramid &lt;方块&gt; &lt;高度&gt;生成实心金字塔，$l=2h-1$，玩家脚在底面中心。 //hpyramid &lt;方块&gt; &lt;高度&gt;生成空心金字塔。 直线必须是默认选区模式(长方体选区模式//sel cuboid)。相当于选择直线两端点。line &lt;方块&gt; [直径]在选区的两个端点（pos1和pos2）之间生成直线线条，不填直径就是最细的线。 另，有flag。-h 生成中空线条，类似与管道。 曲线必须是多面体选区模式//sel convex。相当于从始端开始选择若干曲线上的点，其连线就是目标曲线。curve &lt;方块&gt; [直径]根据选择点顺序生成曲线。 另，有flag。-h 生成中空线条，类似与管道。 剪贴板复制//copy复制选区内容，选好复制时的站位！ 粘贴//paste粘贴剪贴板内的内容，现在复制时站位的作用就体现出来了，复制时玩家与选区的相对位置会保留，粘贴的副本也会保持一样的相对位置。 另，有flag。-a 粘贴时忽略空气方块，不会让空气方块破坏其他原有方块-s 粘贴后，选区从原区域换到复制出来的新区域-o 在原位置粘贴，修改结构不满意可以用此还原 多flag一起用：-a -s或者-as 剪切//cut 旋转旋转剪贴板内的内容，并非世界内的内容，即旋转后要粘贴才能生成结构。 //rotate &lt;Y轴&gt; [X轴] [Z轴]单位为角度，如90表示旋转90度。南北为z，东西为x。用左手判断旋转方向，大拇指指向坐标轴正方向，四指为旋转方向。旋转操作会以复制时的站位为旋转中心。 镜像镜像剪贴板内的内容，并非世界内的内容，即镜像后要粘贴才能生成结构。 //flip [方向]方向：n与s一样，u与d一样，w与e一样。同样是相对位置机制。 清空剪贴板/clearclipboard注意是单个斜杠。 跨存档复制//schematic save [文件名]将剪贴板内容导出到文件中，可缩写为 //schem。文件位置：\\你玩的游戏版本位置\\config\\worldedit\\schematics //schematic load [文件名]在另一个存档内将文件内容导入到剪贴板。 //schematic list &lt;flag&gt;查看已有文件列表。可选flag。-d 时间正序排列-n 时间倒序排列-p &lt;x&gt; 显示第x页 //schematic delet [文件名]删除文件 选区模式清空区域选择//desel 区域选错了，或者不想妨碍下次选区，将当前选点和选区删除，重新选择 长方体选区//sel cuboid默认的模式。左键，第一个点。右键，第二个点。结束。 扩展式长方体选区//sel extend左键，第一个点A。右键，第二个点B。AB构成选区1选区还有没包括的。右键，第三个点C。BC构成选区2。总区域为选区1，2。还可以继续加。 球体选区//sel sphere左键，球心。右键，球面。区域不满意？右键，新球面。 椭球体选区//sel ellipsoid左键，中心。右键，面。右键，面。继续右键以调整。 多边形选区//sel poly左键，起始顶点。右键，顶点。右键，顶点。……可以不同高，选择不同高的顶点使选区变成柱形。 圆（椭）柱体选区//sel cyl左键，中心。右键，面。右键，面。…… 三维多面体选区//sel convex左键，起始顶点。右键，顶点。右键，顶点。…… 人物脱困/unstuck传送至最近空位，当卡在方块里时使用，简写/!。 闪现/jumpto闪现到指针位置，如果指向墙，则到墙顶。或手持指南针，左键。 穿墙/thru或手持指南针，右键。 电梯/ascend [层数]在建筑中，上升，默认上升一层。 /descend [层数]下降 登顶/ceil [预留量]传送到结构顶部，头顶着天花板（预留量不填时），并在脚下放置玻璃方块。 普通上升/up &lt;距离&gt;向上指定距离，并放置玻璃。可以直接/up在脚下生成方块，不用setblock了。选区确定四角时也方便了。","categories":[{"name":"软件教程","slug":"软件教程","permalink":"http://xiiyue.gitee.io/categories/软件教程/"}],"tags":[{"name":"Game","slug":"Game","permalink":"http://xiiyue.gitee.io/tags/Game/"}]},{"title":"Markdown个人使用语法记录","slug":"markdown个人使用语法记录","date":"2020-02-19T11:50:17.000Z","updated":"2020-02-24T06:35:36.971Z","comments":true,"path":"2020/02/19/markdown个人使用语法记录/","link":"","permalink":"http://xiiyue.gitee.io/2020/02/19/markdown个人使用语法记录/","excerpt":"避免反复上网查以前找过的。","text":"避免反复上网查以前找过的。 目录[toc] 输入后在该位置自动生成目录效果： [toc] 标题# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 效果： 文字修饰斜体*斜体* 一个星号_斜体_ 一个下划线 效果： 斜体 斜体 粗体**粗体** 两个星号__粗体__ 两个下划线 效果： 粗体 粗体 斜粗体***斜粗体*** 三个星号___斜粗体___ 三个下划线 效果： 斜粗体 斜粗体 下划线&lt;u&gt;下划线&lt;/u&gt; 效果： 下划线 删除线~~删除线~~ 效果： 删除线 代码行内代码`代码` 效果：代码 代码块​ 代码块代码​```效果： 代码块代码## 引用### 单层引用 引用内容效果：&gt; 引用内容### 多层引用 引用内容 引用内容效果：&gt; 引用内容&gt;&gt; &gt; 内层引用## 分割线 * 效果：１***２---３___## 符号### 被markdown征用而无法直接显示出来利用转义符 \\\\`*_\\{\\}[]()#+-.!效果：\\\\\\`\\*\\_\\&#123;\\&#125;\\[\\]\\(\\)\\#\\+\\-\\.\\!### 特殊符号 &copy; 版权&reg; 注册商标&trade; 商标&nbsp; 空格&amp; 和号&quot; 引号&apos; 撇号&lt; 小于号&gt; 大于号&ne; 不等号&le; 小于等于&ge; 大于等于&cent; 分&pound; 磅&euro; 欧元&yen; 元&sect; 节&times; 乘号&divide; 除号&plusmn; 正负号**分号也要输入效果：&amp;copy;&amp;reg;&amp;trade;&amp;nbsp; &amp;amp; &amp;quot; &amp;apos;&amp;lt; &amp;gt; &amp;ne;&amp;le; &amp;ge;&amp;cent;&amp;pound; &amp;euro;&amp;yen;&amp;sect; &amp;times; &amp;divide; &amp;plusmn; 另提供HTML特殊字符编码对照表![38a6XQ.png](https://s2.ax1x.com/2020/02/24/38a6XQ.png)## 图片 注意：没有引号## 超链接### 样式1 百度效果：[百度](https://www.baidu.com/)### 样式2 百度然后在任何地方定义标签： 效果：[百度][标签]可以把标签统一放在末尾，标签的名字也是自定义的[标签]: https://www.baidu.com/### 样式2（变种） 百度不要标签，直接定义链接名字 效果：[百度][]可以把标签统一放在末尾，标签的名字也是自定义的[百度]: https://www.baidu.com/### 样式3直接插入链接 https://www.baidu.com/效果：&lt;https://www.baidu.com/&gt;## 列表### 无序列表 无序列表1 无序列表2 无序列表3三种符号的效果都是一样的效果：* 无序列表1+ 无序列表2- 无序列表3### 多层级无序列表 无序列表1TAB 无序列表2TABTAB 无序列表3TAB是按TAB键。效果：* 无序列表1 * 无序列表2 * 无序列表3### 有序列表 有序列表1 有序列表2 有序列表3 效果：1. 有序列表12. 有序列表23. 有序列表3### 多层级有序列表 有序列表1 有序列表2TAB1. 有序列表2-1TAB2. 有序列表2-2 有序列表3效果：1. 有序列表12. 有序列表2 1. 有序列表2-1 2. 有序列表2-23. 有序列表3### 任务列表 [ ] 任务1 [x] 任务2- [ ] 任务1- [x] 任务2## 表格快捷键 Ctrl + t可以弹出行列选项或者自己手打 左对齐 居中 右对齐 第一行 1 a 第二行 2 b 第三行 3 c ```空格随意，加空格只是为在编辑时看起来是一列一列对齐的，比如第二行故意不对齐，但显示出来是正常的。设置对齐方式时，多余的’-‘也是为了在编辑时有良好的可读性，实际上只需一个’-‘。效果：| 左对齐 | 居中 | 右对齐 || :——- |:——:| ——-:|| 第一行 | 1 | a || 第二行 | 2|b || 第三行 | 3 | c |","categories":[{"name":"软件教程","slug":"软件教程","permalink":"http://xiiyue.gitee.io/categories/软件教程/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"http://xiiyue.gitee.io/tags/Markdown/"}]},{"title":"基于TinyPNG所提供API的自动上传压缩可视化py脚本","slug":"基于TinyPNG所提供API的自动上传压缩可视化py脚本","date":"2020-02-02T11:15:12.000Z","updated":"2020-02-24T06:13:16.120Z","comments":true,"path":"2020/02/02/基于TinyPNG所提供API的自动上传压缩可视化py脚本/","link":"","permalink":"http://xiiyue.gitee.io/2020/02/02/基于TinyPNG所提供API的自动上传压缩可视化py脚本/","excerpt":"0 引言用md写发布到网络上的文章需要利用图床，如果图片体积太大，不仅上传图床需要时间，网页加载也要时间，所以可以考虑减小图片体积。经过一番搜索，找到了TinyPNG在线压缩网站，只需图片拖进网站，然后等待，然后下载。浏览器下载完后要切换到下载目录，剪切图片，跳回图片保存目录替换图片，如果下载时指定目录的话，下次写另一篇文章，又要换到另一个位置，烦死了！","text":"0 引言用md写发布到网络上的文章需要利用图床，如果图片体积太大，不仅上传图床需要时间，网页加载也要时间，所以可以考虑减小图片体积。经过一番搜索，找到了TinyPNG在线压缩网站，只需图片拖进网站，然后等待，然后下载。浏览器下载完后要切换到下载目录，剪切图片，跳回图片保存目录替换图片，如果下载时指定目录的话，下次写另一篇文章，又要换到另一个位置，烦死了！ 1 模型的建立我会为每一篇文章指定一个图片保存目录，方便以后管理，而截图时直接就将图片保存在该目录下，所以我希望直接将图片拖进程序，然后它就直接变成了压缩成品，没有其他操作。 窗口接收文件；一个标签，显示文字“图片”，一个标签，文字显示为拖入图片的绝对地址；一个标签，显示目前状态；一个按钮，按下则开始工作。理论上，不需要按钮，但是由本人控制何时开始感觉更有安全感。 为了方便查看各控件的坐标，在cad中做了初步的规划，由于界面实在太简单，也不准备再更改，就没有保存二维图，在此仅列出控件几何参数。 标签 定义名 位置 尺寸 窗体 xiiyue 无 500,400 静态标签 label_s 40,65 60,30 路径标签 label_picfile 130,50 330,60 状态标签 label_state 40,120 420,160 确认按钮 butn 200,305 100,30 2 代码实现2.1 窗体新建类，用于创建空白控件，自动成为窗体。class xiiyue(QWidget): pass 其实不需要新建继承QWidget的类，我是边学边写，跟着写。新建类后想要运行它，在以下代码if __name__ == \"__main__\": app = QApplication(sys.argv) # 创建应用 xiyue = xiiyue() # 实例化 xiyue.show() # 显示窗口 sys.exit(app.exec_()) # 持续运行 这句if使得其他文件导入此文件不会运行，而执行此文件才会运行。我本来就打算在一个文件里完成所有代码，因此不需要考虑导入的问题，不过这种格式的确有逻辑清晰的优点，这样写也没毛病。写到此时用到了QWidget，QApplication，sys，因此文件开头导入模块：import sysfrom PyQt5.QtWidgets import QWidget,QApplication 继续调整主窗体，改写init。1，继承所有，毕竟不能影响QWidget的原本功能2，设置窗体名3，设置窗口大小4，加载子控件 def __init__(self): super(xiiyue, self).__init__() # 设置窗口名 self.setWindowTitle(\"图片压缩\") # 定义窗口大小 self.resize(500, 400) # 布置控件 self.load() 为了保证init的简洁明了，子控件的建立和外观设定都放在了load()函数里。 2.2 子控件定义load()函数def load(self): pass 其中为各子控件的创建和设置代码 静态标签部分 # 建标签self.label_s = QLabel(self)# 标签位置和尺寸self.label_s.setGeometry(40, 65, 60, 30)# 标签格式，字体颜色红，大小15像素，加粗self.label_s.setStyleSheet(\"color:red;font-size:15px;font-weight:bold;\")# 标签居中设置，水平垂直居中self.label_s.setAlignment(QtCore.Qt.AlignCenter)# 标签文字self.label_s.setText(\"图片\") 路径标签部分 self.label_picfile = QLabel(self)self.label_picfile.setGeometry(130, 50, 330, 60)# 标签格式，背景白，字体大小15像素self.label_picfile.setStyleSheet(\"background-color:white;font-size:15px;\")# 标签居中设置，左对齐，垂直居中self.label_picfile.setAlignment(QtCore.Qt.AlignLeft |QtCore.Qt.AlignVCenter)self.label_picfile.setText(self.file_name)# 标签设置自动换行self.label_picfile.setWordWrap(True) 这里有个变量file_name没有定义，它是存放文件名的变量，在init中加上self.file_name = '' 状态标签部分 self.label_state = QLabel(self)self.label_state.setGeometry(40, 120, 420, 160)self.label_state.setAlignment(QtCore.Qt.AlignCenter)self.label_state.setStyleSheet(\"font-size:50px;font-weight:bold;\")self.label_state.setText(\"就绪\") 确认按钮部分 self.butn = QPushButton(self)self.butn.setGeometry(200,305,100,30)self.butn.setText(\"开始压缩\") 以上用到了QLabel、QPushButton和QtCore同样要导入from PyQt5.QtWidgets import QLabel,QPushButtonfrom PyQt5 import QtCore 2.3 拖入图片功能现在程序的外形都有了，如图所示。 但是还没有相应的功能，本小节就实现运行图片拖入程序并获取位置信息。在init中加入代码启用拖拽功能# 启用拖拽self.setAcceptDrops(True) 文件拖拽如控件时会自动调用dragEnterEvent函数，因此在类中重写此函数。# evn参数接收拖入事件def dragEnterEvent(self, evn): # 获取文件名 self.file_name=evn.mimeData().text() # 截取需要部分 self.file_name=self.file_name[8:] # 设置路径标签文本 self.label_picfile.setText(self.file_name) 路径标签中显示出路径说明一切都准备好了，可以点击按钮开始压缩。evn.mimeData().text()返回的路径开头8个字符是“file:///”，需要将其剪切。 2.4 按钮功能按下按钮就开始调用压缩函数，但是有一个问题，上传图片给tinypng然后返回结果需要一定的时间，而在这段时间内，程序会未响应的现象，心灰之余，该项目被我放弃了好长时间。现在闲着没事，搜索了一下，发现多线程可以解决这类问题。按钮功能通过信号与槽机制实现，定义槽函数，即按钮按下后需要做的事def butn_job(self): if self.file_name != '': # 设置状态标签文本，表明正在压缩 self.label_state.setText(\"等\") # 新建线程，指明该线程需执行的函数 self.thread_deal = threading.Thread(target=self.deal_pic) # 线程启动 self.thread_deal.start() # 没有拖入图片时不工作 else: self.label_state.setText(\"拖入图片\") 线程需要threading模块import threading 按钮的信号需要与槽连接，内置的信号为clicked函数，在init中连接self.butn.clicked.connect(self.butn_job) 2.5 压缩直接写def deal_pic(self): # 断开按钮信号与槽的连接，处理图片时按钮点击无反应 self.butn.blockSignals(True) # 压缩图片 source = tinify.from_file(self.file_name) # 保存图片 source.to_file(self.file_name) # 记录本月上传次数 compressions_this_month =str(tinify.compression_count) # 次数没地方放，就显示在标题处吧 self.setWindowTitle(\"图片压缩\" + \"本月使用：\" + compressions_this_month) # 设置状态标签 self.label_state.setText(\"就绪\") # 恢复按钮信号与槽的连接 self.butn.blockSignals(False) # 重置路径标签 self.file_name = '' self.label_picfile.setText(self.file_name) 需要用到tinify模块import tinify 需要提供key在程序开头就给它加上tinify.key = \"xxxxxxxxxxxxxxxxxxx\" 至此所有工作都完成，完整代码在最后，接下来是试验。 3 实机试验我在使用的时候发现，未响应问题确实解决了，但等待时间也太久了，我加了一个计时功能以便直观感受。导入time模块tinify.key = \"xxxxxxxxxxxxxxxxxxx\" 在图片压缩的两行代码上下加入时间记录函数，并将耗时显示在标题t1 = time.time()source = tinify.from_file(self.file_name)source.to_file(self.file_name)t2 = time.time()t = t2 - t1compressions_this_month =str(tinify.compression_count)self.setWindowTitle(\"图片压缩\" + \"本月使用：\" + compressions_this_month + \"用时：\" + str(t)) 随便个截图，277k，开始压缩了，看图 结束了，看图 37s，然后我下载了一个压缩图片的软件。 最后，此项目结束，有所收获，并尽量还原实际的思考过程。 完整代码# -*- coding:utf-8 -*-# by xiyueimport sysimport threadingimport tinifyimport timefrom PyQt5.QtWidgets import QWidget,QLabel,QApplication,QPushButtonfrom PyQt5 import QtCoreclass xiiyue(QWidget): def __init__(self): super(xiiyue, self).__init__() #定义变量 self.file_name = '' # 窗口标题 self.setWindowTitle(\"图片压缩\") # 定义窗口大小 self.resize(500, 400) #布置控件 self.load() # 启用Drops方法 self.setAcceptDrops(True) #signal and slot self.butn.clicked.connect(self.butn_job) def load(self): #静态标签 self.label_s = QLabel(self) self.label_s.setGeometry(40, 65, 60, 30) self.label_s.setStyleSheet(\"color:red;font-size:15px;font-weight:bold;\") self.label_s.setAlignment(QtCore.Qt.AlignCenter) self.label_s.setText(\"图片\") #路径标签 self.label_picfile = QLabel(self) self.label_picfile.setGeometry(130, 50, 330, 60) self.label_picfile.setStyleSheet(\"background-color:white;font-size:15px;\") self.label_picfile.setAlignment(QtCore.Qt.AlignLeft |QtCore.Qt.AlignVCenter) self.label_picfile.setText(self.file_name) self.label_picfile.setWordWrap(True) #状态标签 self.label_state = QLabel(self) self.label_state.setGeometry(40, 120, 420, 160) self.label_state.setAlignment(QtCore.Qt.AlignCenter) self.label_state.setStyleSheet(\"font-size:50px;font-weight:bold;\") self.label_state.setText(\"就绪\") #确认按钮 self.butn = QPushButton(self) self.butn.setGeometry(200,305,100,30) self.butn.setText(\"开始压缩\") # 鼠标拖入事件 def dragEnterEvent(self, evn): self.file_name=evn.mimeData().text() self.file_name=self.file_name[8:] self.label_picfile.setText(self.file_name) # 按钮函数 def butn_job(self): if self.file_name != '': self.label_state.setText(\"等\") self.thread_deal = threading.Thread(target=self.deal_pic) self.thread_deal.start() else: self.label_state.setText(\"拖入图片\") # 压缩图片 def deal_pic(self): self.butn.blockSignals(True) t1 = time.time() source = tinify.from_file(self.file_name) source.to_file(self.file_name) t2 = time.time() t = t2 - t1 compressions_this_month =str(tinify.compression_count) self.setWindowTitle(\"图片压缩\" + \"本月使用：\" + compressions_this_month + \"用时：\" + str(t)) self.label_state.setText(\"就绪\") self.butn.blockSignals(False) self.file_name = '' self.label_picfile.setText(self.file_name)if __name__ == \"__main__\": tinify.key = \"xxxxxxxxxxxxxxxxxxxxxxxxx\" app = QApplication(sys.argv) xiyue = xiiyue() xiyue.show() sys.exit(app.exec_())","categories":[{"name":"编程","slug":"编程","permalink":"http://xiiyue.gitee.io/categories/编程/"}],"tags":[{"name":"python","slug":"python","permalink":"http://xiiyue.gitee.io/tags/python/"}]},{"title":"AnsysWorkbench-01-热源扩散","slug":"20191109_AnsysWorkbench_01_热源扩散","date":"2019-11-09T11:47:25.000Z","updated":"2020-02-24T05:39:53.853Z","comments":true,"path":"2019/11/09/20191109_AnsysWorkbench_01_热源扩散/","link":"","permalink":"http://xiiyue.gitee.io/2019/11/09/20191109_AnsysWorkbench_01_热源扩散/","excerpt":"1T的硬盘只有300G的空余了！明年蠢驴的2077一出，再复习一下GTA5和巫师，岂不是没地方学习了？无奈之下只好开始清理磁盘，先用spacesniffer软件看看文件的分布情况，然后我发现了40G的ansys分析结果。。。其他的也不用看了，仿真文字化工程启动！工程目的是记录仿真过程，以后忘记了也能迅速上手。该工程下的所有场景都是经过极端简化和重新假设的，毕竟原模型要处理的细节很多，与主题无关。","text":"1T的硬盘只有300G的空余了！明年蠢驴的2077一出，再复习一下GTA5和巫师，岂不是没地方学习了？无奈之下只好开始清理磁盘，先用spacesniffer软件看看文件的分布情况，然后我发现了40G的ansys分析结果。。。其他的也不用看了，仿真文字化工程启动！工程目的是记录仿真过程，以后忘记了也能迅速上手。该工程下的所有场景都是经过极端简化和重新假设的，毕竟原模型要处理的细节很多，与主题无关。 场景介绍有个东西在稳定发热，知道发热功率。它在向外界传热，我们要观察它周围物体的温度变化。 仿真步骤实录1 建立模型用solidwork，然后存为 .x_t 文件。（Ansys18.2，文件为中文名没出现问题） 2 导入WorkBench先用Steady-State Thermal模块进行稳态热分析，从工具箱也就是Toolbox中找到，并拖动它到主界面中。 （右键，在新标签页查看应该可看清晰图） 上面的模块A、B、C是我已经完成的，现在为了说明添加过程，又拖了一个Steady-State Thermal模块。模块A不是必须的，它相当于在模块A中先处理了模型，然后传给了模块B中的B3：Geometry项。如果一开始就添加的是Steady-State Thermal，那它就是模块A，A3就是Geometry项，对Geometry右键，将x_t 文件传进来。 选择Browse后就是在跳出的对话框里找你要导入的文件。导入后基本上就不用再处理了，不然为什么要用其他的三维建模软件呢？ 3 材料双击Steady-State Thermal模块的第二行Engineering Data项，右键选择edit也行。现在进入了新的区域，在材料选择区中添加材料，先去自带的材料库中找，就是图中的A方案，或者在最后一栏输入自定义的材料名，自己建新材料，图中的B方案。 自定义材料需要添加材料的性质，从库中加的也可以添加更多材料性质。材料选择区的左边有Toolbox，里面包含了当前分析所需要的材料属性，如果分析只需要材料的密度，那Toolbox也只会显示密度属性。软件一打开就自选了默认材料Structural Steel，它有什么我就选什么。在选择属性的过程中可能会出现某些性质没有显示出来，我猜是Toolbox窗口没刷新，我点击了右边材料选择区的空白处就好了。然后关掉Engineering Data窗口，回到第二步的主界面。 4 稳态仿真设置双击Steady-State Thermal模块的第四行Model项。第一步Geometry分支下是模型的所有实体，单击选中其中一个，可以在detail框中设置详细内容，现在把材料分别赋给每一个实体。 第二步Coordinate Systems分支，不动。 第三步Connections分支，用于设置实体之间的连接方式，默认固定连接（bonded） 第四步Mesh分支，用于画网格，不想手动处理，直接让机器自动生成网格，也就是不好看而已。 第五步Steady-State Thermal分支，稳态热分析的详细设置。右键Steady-State Thermal，选择insert，其中就是添加载荷、边界条件的选项。 添加convection，设置对流热传递，比如暴露在空气中，则有空气对流换热。在detail框中，Geometry一栏选择要施加的位置；Film coefficient设置换热系数；Ambient temperature设置环境温度。 选择对象的时候需要考虑选择点、线、面、体，在模型界面空白处右键，然后选择Cursor Mode，其中就有鼠标选择模式。 添加Internal Heat Generation，实体以稳定速度产生热能，即每单位时间在单位体积产生的热能。在detail框中，Geometry一栏选择要施加的位置；Magnitude一栏选择发热量，单位是 瓦/体积，需要根据具体信息换算一下。 选择对象又会碰到一个问题，要选择的对象被其他实体挡住了，可以在第一步中选择实体按F9隐藏，或者右键选Hide Body。 Solution分支，右键Solution，insert选择想查看的结果，这里加入的是Temperature。数据是随便填的，结果吓人但不关键，关键是过程。稳态分析只展示了最后结果，仿真时间是1s，可以在第五步Steady-State Thermal分支中的Analysis Settings中设置。 5 瞬态仿真设置（该过程有点问题）用瞬态热分析模块看温度随时间的变化。在添加模块的主界面找到Transient Thermal模块，将其拖到Steady-State Thermal模块的第六行Solution项上，继承它的计算结果。效果应该是本文第一幅图中所表示的，Steady-State Thermal模块中的Solution指向Transient Thermal模块中的Setup。 打开Transient Thermal模块的Model项，可以看到在第五步Steady-State Thermal分支下多了个Transient Thermal。 第六步Transient Thermal分支。 Analysis Settings设置分析时间，分析步长。step end time设置分析的总时间，auto time setpping打开后可以设置步长，即多少秒计算一次，最低多少秒一步，最大多少秒一步。我的40G就是这里产生的，时间长，步长短，计算次数就多，计算结果的数据就多。 按我的意思应该可以直接计算了，但软件提示必须加个条件。也就是右键Transient Thermal后，在insert中必须选一个，我就把convection在这又加了一次，我觉得有问题的地方就在这里。 Solution分支与上面一样，Temperature的detail中可以选择任意时间的结果；Graph界面可以看曲线，温度还有下降趋势，应该把仿真时间调大再分析；播放按钮打开后能在模型界面看变化；Tabular Data界面可以把每一步的结果复制下来。 完！","categories":[{"name":"软件教程","slug":"软件教程","permalink":"http://xiiyue.gitee.io/categories/软件教程/"}],"tags":[{"name":"AnsysWorkbench","slug":"AnsysWorkbench","permalink":"http://xiiyue.gitee.io/tags/AnsysWorkbench/"}]},{"title":"Mathematica使用记录01-分式","slug":"20191023_Mathematica使用记录_01_分式","date":"2019-10-23T08:02:08.000Z","updated":"2019-10-30T13:32:23.025Z","comments":true,"path":"2019/10/23/20191023_Mathematica使用记录_01_分式/","link":"","permalink":"http://xiiyue.gitee.io/2019/10/23/20191023_Mathematica使用记录_01_分式/","excerpt":"&emsp;&emsp;做作业的时候，碰到了分子还可以分母不忍直视的分式，为了做反z变换，必须将其化为几个可以查表的分式，虽然我可以手算，但是嘛。。。","text":"&emsp;&emsp;做作业的时候，碰到了分子还可以分母不忍直视的分式，为了做反z变换，必须将其化为几个可以查表的分式，虽然我可以手算，但是嘛。。。 Apart-我裂开了&emsp;&emsp;函数原型：Apart[expr,var]&emsp;&emsp;expr就是你要处理的表达式&emsp;&emsp;var是可选的，可以不填，如果你的表达式中有多个变量，如x和y，填x则将y视为常数处理。 &emsp;&emsp;例： $\\frac{1}{x^4-2 x^2+1}$ &emsp;&emsp;在Mathematica中输入 Apart[1/(1-2*x^2+x^4)] &emsp;&emsp;shift 回车，输出结果如下图 &emsp;&emsp;如果想把分开的几个分式合并为一个呢？ Together-通分求和&emsp;&emsp;函数原型：Together[expr]&emsp;&emsp;expr就是你要处理的表达式&emsp;&emsp;在Mathematica中输入 Together[1/(4*(-1+x)^2)-1/(4*(-1+x))+1/(4*(1+x)^2)+1/(4*(1+x))] &emsp;&emsp;shift 回车，输出结果如下图 &emsp;&emsp;可以看到，结果并不是完全展开式。 &emsp;&emsp;所以$\\frac{1}{(x-1)^2 (x+1)^2}$跟$\\frac{1}{4 (x-1)^2}+\\frac{1}{4 (x+1)}+\\frac{1}{4 (x+1)^2}-\\frac{1}{4 (x-1)}$才是真正的一对？ &emsp;&emsp;如果想得到展开式呢？ Expand-展开&emsp;&emsp;函数原型：Expand[expr]&emsp;&emsp;expr就是你要处理的表达式&emsp;&emsp;在Mathematica中输入 Expand[(4*(-1+x)^2)] &emsp;&emsp;shift 回车，输出结果如下图 &emsp;&emsp;但是我想直接处理分式，应该选择Expand的扩展ExpandDenominator函数，即展开分母。如图 &emsp;&emsp;回过头处理刚才Together没搞定的多个分式。 &emsp;&emsp;第一次输入的是几个分式之和，它竟然是一个一个分开处理的。我只好先Together，再ExpandDenominator。 Factor-因式分解(没有裂开)&emsp;&emsp;函数原型：Factor[expr] &emsp;&emsp;在Mathematica中输入 Factor[1/(4*x^2-8*x+4)] &emsp;&emsp;输出结果如下图 &emsp;&emsp;另外，网上查Wolfram语法时发现用谷歌访问助手能“流畅”浏览，总比打不开好！","categories":[{"name":"研究学习","slug":"研究学习","permalink":"http://xiiyue.gitee.io/categories/研究学习/"}],"tags":[{"name":"Mathematic","slug":"Mathematic","permalink":"http://xiiyue.gitee.io/tags/Mathematic/"}]}]}