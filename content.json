{"meta":{"title":"兮xiyue曰","subtitle":null,"description":null,"author":"xiyue","url":"http://xiiyue.gitee.io","root":"/"},"pages":[{"title":"about","date":"2019-09-25T11:54:31.000Z","updated":"2019-10-27T08:56:19.740Z","comments":true,"path":"about/index.html","permalink":"http://xiiyue.gitee.io/about/index.html","excerpt":"","text":"没啥"},{"title":"archives","date":"2019-09-23T12:49:21.000Z","updated":"2019-09-26T12:31:57.469Z","comments":true,"path":"archives/index.html","permalink":"http://xiiyue.gitee.io/archives/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-09-27T09:57:54.000Z","updated":"2019-10-26T15:27:59.084Z","comments":false,"path":"tags/index.html","permalink":"http://xiiyue.gitee.io/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-09-23T12:24:30.000Z","updated":"2019-10-26T15:28:28.958Z","comments":false,"path":"categories/index.html","permalink":"http://xiiyue.gitee.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"基于TinyPNG所提供API的自动上传压缩可视化py脚本","slug":"基于TinyPNG所提供API的自动上传压缩可视化py脚本","date":"2020-02-02T11:15:12.000Z","updated":"2020-02-04T03:55:21.627Z","comments":true,"path":"2020/02/02/基于TinyPNG所提供API的自动上传压缩可视化py脚本/","link":"","permalink":"http://xiiyue.gitee.io/2020/02/02/基于TinyPNG所提供API的自动上传压缩可视化py脚本/","excerpt":"0 引言用md写发布到网络上的文章需要利用图床，如果图片体积太大，不仅上传图床需要时间，网页加载也要时间，所以可以考虑减小图片体积。经过一番搜索，找到了TinyPNG在线压缩网站，只需图片拖进网站，然后等待，然后下载。浏览器下载完后要切换到下载目录，剪切图片，跳回图片保存目录替换图片，如果下载时指定目录的话，下次写另一篇文章，又要换到另一个位置，烦死了！","text":"0 引言用md写发布到网络上的文章需要利用图床，如果图片体积太大，不仅上传图床需要时间，网页加载也要时间，所以可以考虑减小图片体积。经过一番搜索，找到了TinyPNG在线压缩网站，只需图片拖进网站，然后等待，然后下载。浏览器下载完后要切换到下载目录，剪切图片，跳回图片保存目录替换图片，如果下载时指定目录的话，下次写另一篇文章，又要换到另一个位置，烦死了！ 1 模型的建立我会为每一篇文章指定一个图片保存目录，方便以后管理，而截图时直接就将图片保存在该目录下，所以我希望直接将图片拖进程序，然后它就直接变成了压缩成品，没有其他操作。 窗口接收文件；一个标签，显示文字“图片”，一个标签，文字显示为拖入图片的绝对地址；一个标签，显示目前状态；一个按钮，按下则开始工作。理论上，不需要按钮，但是由本人控制何时开始感觉更有安全感。 为了方便查看各控件的坐标，在cad中做了初步的规划，由于界面实在太简单，也不准备再更改，就没有保存二维图，在此仅列出控件几何参数。 标签 定义名 位置 尺寸 窗体 xiiyue 无 500,400 静态标签 label_s 40,65 60,30 路径标签 label_picfile 130,50 330,60 状态标签 label_state 40,120 420,160 确认按钮 butn 200,305 100,30 2 代码实现2.1 窗体新建类，用于创建空白控件，自动成为窗体。class xiiyue(QWidget): pass 其实不需要新建继承QWidget的类，我是边学边写，跟着写。新建类后想要运行它，在以下代码if __name__ == \"__main__\": app = QApplication(sys.argv) # 创建应用 xiyue = xiiyue() # 实例化 xiyue.show() # 显示窗口 sys.exit(app.exec_()) # 持续运行 这句if使得其他文件导入此文件不会运行，而执行此文件才会运行。我本来就打算在一个文件里完成所有代码，因此不需要考虑导入的问题，不过这种格式的确有逻辑清晰的优点，这样写也没毛病。写到此时用到了QWidget，QApplication，sys，因此文件开头导入模块：import sysfrom PyQt5.QtWidgets import QWidget,QApplication 继续调整主窗体，改写init。1，继承所有，毕竟不能影响QWidget的原本功能2，设置窗体名3，设置窗口大小4，加载子控件 def __init__(self): super(xiiyue, self).__init__() # 设置窗口名 self.setWindowTitle(\"图片压缩\") # 定义窗口大小 self.resize(500, 400) # 布置控件 self.load() 为了保证init的简洁明了，子控件的建立和外观设定都放在了load()函数里。 2.2 子控件定义load()函数def load(self): pass 其中为各子控件的创建和设置代码 静态标签部分 # 建标签self.label_s = QLabel(self)# 标签位置和尺寸self.label_s.setGeometry(40, 65, 60, 30)# 标签格式，字体颜色红，大小15像素，加粗self.label_s.setStyleSheet(\"color:red;font-size:15px;font-weight:bold;\")# 标签居中设置，水平垂直居中self.label_s.setAlignment(QtCore.Qt.AlignCenter)# 标签文字self.label_s.setText(\"图片\") 路径标签部分 self.label_picfile = QLabel(self)self.label_picfile.setGeometry(130, 50, 330, 60)# 标签格式，背景白，字体大小15像素self.label_picfile.setStyleSheet(\"background-color:white;font-size:15px;\")# 标签居中设置，左对齐，垂直居中self.label_picfile.setAlignment(QtCore.Qt.AlignLeft |QtCore.Qt.AlignVCenter)self.label_picfile.setText(self.file_name)# 标签设置自动换行self.label_picfile.setWordWrap(True) 这里有个变量file_name没有定义，它是存放文件名的变量，在init中加上self.file_name = '' 状态标签部分 self.label_state = QLabel(self)self.label_state.setGeometry(40, 120, 420, 160)self.label_state.setAlignment(QtCore.Qt.AlignCenter)self.label_state.setStyleSheet(\"font-size:50px;font-weight:bold;\")self.label_state.setText(\"就绪\") 确认按钮部分 self.butn = QPushButton(self)self.butn.setGeometry(200,305,100,30)self.butn.setText(\"开始压缩\") 以上用到了QLabel、QPushButton和QtCore同样要导入from PyQt5.QtWidgets import QLabel,QPushButtonfrom PyQt5 import QtCore 2.3 拖入图片功能现在程序的外形都有了，如图所示。 但是还没有相应的功能，本小节就实现运行图片拖入程序并获取位置信息。在init中加入代码启用拖拽功能# 启用拖拽self.setAcceptDrops(True) 文件拖拽如控件时会自动调用dragEnterEvent函数，因此在类中重写此函数。# evn参数接收拖入事件def dragEnterEvent(self, evn): # 获取文件名 self.file_name=evn.mimeData().text() # 截取需要部分 self.file_name=self.file_name[8:] # 设置路径标签文本 self.label_picfile.setText(self.file_name) 路径标签中显示出路径说明一切都准备好了，可以点击按钮开始压缩。evn.mimeData().text()返回的路径开头8个字符是“file:///”，需要将其剪切。 2.4 按钮功能按下按钮就开始调用压缩函数，但是有一个问题，上传图片给tinypng然后返回结果需要一定的时间，而在这段时间内，程序会未响应的现象，心灰之余，该项目被我放弃了好长时间。现在闲着没事，搜索了一下，发现多线程可以解决这类问题。按钮功能通过信号与槽机制实现，定义槽函数，即按钮按下后需要做的事def butn_job(self): if self.file_name != '': # 设置状态标签文本，表明正在压缩 self.label_state.setText(\"等\") # 新建线程，指明该线程需执行的函数 self.thread_deal = threading.Thread(target=self.deal_pic) # 线程启动 self.thread_deal.start() # 没有拖入图片时不工作 else: self.label_state.setText(\"拖入图片\") 线程需要threading模块import threading 按钮的信号需要与槽连接，内置的信号为clicked函数，在init中连接self.butn.clicked.connect(self.butn_job) 2.5 压缩直接写def deal_pic(self): # 断开按钮信号与槽的连接，处理图片时按钮点击无反应 self.butn.blockSignals(True) # 压缩图片 source = tinify.from_file(self.file_name) # 保存图片 source.to_file(self.file_name) # 记录本月上传次数 compressions_this_month =str(tinify.compression_count) # 次数没地方放，就显示在标题处吧 self.setWindowTitle(\"图片压缩\" + \"本月使用：\" + compressions_this_month) # 设置状态标签 self.label_state.setText(\"就绪\") # 恢复按钮信号与槽的连接 self.butn.blockSignals(False) # 重置路径标签 self.file_name = '' self.label_picfile.setText(self.file_name) 需要用到tinify模块import tinify 需要提供key在程序开头就给它加上tinify.key = \"xxxxxxxxxxxxxxxxxxx\" 至此所有工作都完成，完整代码在最后，接下来是试验。 3 实机试验我在使用的时候发现，未响应问题确实解决了，但等待时间也太久了，我加了一个计时功能以便直观感受。导入time模块tinify.key = \"xxxxxxxxxxxxxxxxxxx\" 在图片压缩的两行代码上下加入时间记录函数，并将耗时显示在标题t1 = time.time()source = tinify.from_file(self.file_name)source.to_file(self.file_name)t2 = time.time()t = t2 - t1compressions_this_month =str(tinify.compression_count)self.setWindowTitle(\"图片压缩\" + \"本月使用：\" + compressions_this_month + \"用时：\" + str(t)) 随便个截图，277k，开始压缩了，看图 结束了，看图 37s，然后我下载了一个压缩图片的软件。 最后，此项目结束，有所收获，并尽量还原实际的思考过程。 完整代码# -*- coding:utf-8 -*-# by xiyueimport sysimport threadingimport tinifyimport timefrom PyQt5.QtWidgets import QWidget,QLabel,QApplication,QPushButtonfrom PyQt5 import QtCoreclass xiiyue(QWidget): def __init__(self): super(xiiyue, self).__init__() #定义变量 self.file_name = '' # 窗口标题 self.setWindowTitle(\"图片压缩\") # 定义窗口大小 self.resize(500, 400) #布置控件 self.load() # 启用Drops方法 self.setAcceptDrops(True) #signal and slot self.butn.clicked.connect(self.butn_job) def load(self): #静态标签 self.label_s = QLabel(self) self.label_s.setGeometry(40, 65, 60, 30) self.label_s.setStyleSheet(\"color:red;font-size:15px;font-weight:bold;\") self.label_s.setAlignment(QtCore.Qt.AlignCenter) self.label_s.setText(\"图片\") #路径标签 self.label_picfile = QLabel(self) self.label_picfile.setGeometry(130, 50, 330, 60) self.label_picfile.setStyleSheet(\"background-color:white;font-size:15px;\") self.label_picfile.setAlignment(QtCore.Qt.AlignLeft |QtCore.Qt.AlignVCenter) self.label_picfile.setText(self.file_name) self.label_picfile.setWordWrap(True) #状态标签 self.label_state = QLabel(self) self.label_state.setGeometry(40, 120, 420, 160) self.label_state.setAlignment(QtCore.Qt.AlignCenter) self.label_state.setStyleSheet(\"font-size:50px;font-weight:bold;\") self.label_state.setText(\"就绪\") #确认按钮 self.butn = QPushButton(self) self.butn.setGeometry(200,305,100,30) self.butn.setText(\"开始压缩\") # 鼠标拖入事件 def dragEnterEvent(self, evn): self.file_name=evn.mimeData().text() self.file_name=self.file_name[8:] self.label_picfile.setText(self.file_name) # 按钮函数 def butn_job(self): if self.file_name != '': self.label_state.setText(\"等\") self.thread_deal = threading.Thread(target=self.deal_pic) self.thread_deal.start() else: self.label_state.setText(\"拖入图片\") # 压缩图片 def deal_pic(self): self.butn.blockSignals(True) t1 = time.time() source = tinify.from_file(self.file_name) source.to_file(self.file_name) t2 = time.time() t = t2 - t1 compressions_this_month =str(tinify.compression_count) self.setWindowTitle(\"图片压缩\" + \"本月使用：\" + compressions_this_month + \"用时：\" + str(t)) self.label_state.setText(\"就绪\") self.butn.blockSignals(False) self.file_name = '' self.label_picfile.setText(self.file_name)if __name__ == \"__main__\": tinify.key = \"xxxxxxxxxxxxxxxxxxxxxxxxx\" app = QApplication(sys.argv) xiyue = xiiyue() xiyue.show() sys.exit(app.exec_())","categories":[{"name":"编程","slug":"编程","permalink":"http://xiiyue.gitee.io/categories/编程/"}],"tags":[{"name":"python","slug":"python","permalink":"http://xiiyue.gitee.io/tags/python/"}]},{"title":"MatlabSimulink-Math Operations","slug":"20200120_MatlabSimulink_Math Operations","date":"2020-01-20T11:17:25.000Z","updated":"2020-01-20T11:41:43.474Z","comments":true,"path":"2020/01/20/20200120_MatlabSimulink_Math Operations/","link":"","permalink":"http://xiiyue.gitee.io/2020/01/20/20200120_MatlabSimulink_Math Operations/","excerpt":"Math Operations模块下的元件都试一下。","text":"Math Operations模块下的元件都试一下。 Abs功能","categories":[{"name":"研究学习","slug":"研究学习","permalink":"http://xiiyue.gitee.io/categories/研究学习/"}],"tags":[{"name":"Matlab","slug":"Matlab","permalink":"http://xiiyue.gitee.io/tags/Matlab/"}]},{"title":"AnsysWorkbench-01-热源扩散","slug":"20191109_AnsysWorkbench_01_热源扩散","date":"2019-11-09T11:47:25.000Z","updated":"2019-11-10T11:36:13.969Z","comments":true,"path":"2019/11/09/20191109_AnsysWorkbench_01_热源扩散/","link":"","permalink":"http://xiiyue.gitee.io/2019/11/09/20191109_AnsysWorkbench_01_热源扩散/","excerpt":"1T的硬盘只有300G的空余了！明年蠢驴的2077一出，再复习一下GTA5和巫师，岂不是没地方学习了？无奈之下只好开始清理磁盘，先用spacesniffer软件看看文件的分布情况，然后我发现了40G的ansys分析结果。。。其他的也不用看了，仿真文字化工程启动！工程目的是记录仿真过程，以后忘记了也能迅速上手。该工程下的所有场景都是经过极端简化和重新假设的，毕竟原模型要处理的细节很多，与主题无关。","text":"1T的硬盘只有300G的空余了！明年蠢驴的2077一出，再复习一下GTA5和巫师，岂不是没地方学习了？无奈之下只好开始清理磁盘，先用spacesniffer软件看看文件的分布情况，然后我发现了40G的ansys分析结果。。。其他的也不用看了，仿真文字化工程启动！工程目的是记录仿真过程，以后忘记了也能迅速上手。该工程下的所有场景都是经过极端简化和重新假设的，毕竟原模型要处理的细节很多，与主题无关。 场景介绍有个东西在稳定发热，知道发热功率。它在向外界传热，我们要观察它周围物体的温度变化。 仿真步骤实录1 建立模型用solidwork，然后存为 .x_t 文件。（Ansys18.2，文件为中文名没出现问题） 2 导入WorkBench先用Steady-State Thermal模块进行稳态热分析，从工具箱也就是Toolbox中找到，并拖动它到主界面中。 （右键，在新标签页查看应该可看清晰图） 上面的模块A、B、C是我已经完成的，现在为了说明添加过程，又拖了一个Steady-State Thermal模块。模块A不是必须的，它相当于在模块A中先处理了模型，然后传给了模块B中的B3：Geometry项。如果一开始就添加的是Steady-State Thermal，那它就是模块A，A3就是Geometry项，对Geometry右键，将x_t 文件传进来。 选择Browse后就是在跳出的对话框里找你要导入的文件。导入后基本上就不用再处理了，不然为什么要用其他的三维建模软件呢？ 3 材料双击Steady-State Thermal模块的第二行Engineering Data项，右键选择edit也行。现在进入了新的区域，在材料选择区中添加材料，先去自带的材料库中找，就是图中的A方案，或者在最后一栏输入自定义的材料名，自己建新材料，图中的B方案。 自定义材料需要添加材料的性质，从库中加的也可以添加更多材料性质。材料选择区的左边有Toolbox，里面包含了当前分析所需要的材料属性，如果分析只需要材料的密度，那Toolbox也只会显示密度属性。软件一打开就自选了默认材料Structural Steel，它有什么我就选什么。在选择属性的过程中可能会出现某些性质没有显示出来，我猜是Toolbox窗口没刷新，我点击了右边材料选择区的空白处就好了。然后关掉Engineering Data窗口，回到第二步的主界面。 4 稳态仿真设置双击Steady-State Thermal模块的第四行Model项。第一步Geometry分支下是模型的所有实体，单击选中其中一个，可以在detail框中设置详细内容，现在把材料分别赋给每一个实体。 第二步Coordinate Systems分支，不动。 第三步Connections分支，用于设置实体之间的连接方式，默认固定连接（bonded） 第四步Mesh分支，用于画网格，不想手动处理，直接让机器自动生成网格，也就是不好看而已。 第五步Steady-State Thermal分支，稳态热分析的详细设置。右键Steady-State Thermal，选择insert，其中就是添加载荷、边界条件的选项。 添加convection，设置对流热传递，比如暴露在空气中，则有空气对流换热。在detail框中，Geometry一栏选择要施加的位置；Film coefficient设置换热系数；Ambient temperature设置环境温度。 选择对象的时候需要考虑选择点、线、面、体，在模型界面空白处右键，然后选择Cursor Mode，其中就有鼠标选择模式。 添加Internal Heat Generation，实体以稳定速度产生热能，即每单位时间在单位体积产生的热能。在detail框中，Geometry一栏选择要施加的位置；Magnitude一栏选择发热量，单位是 瓦/体积，需要根据具体信息换算一下。 选择对象又会碰到一个问题，要选择的对象被其他实体挡住了，可以在第一步中选择实体按F9隐藏，或者右键选Hide Body。 Solution分支，右键Solution，insert选择想查看的结果，这里加入的是Temperature。数据是随便填的，结果吓人但不关键，关键是过程。稳态分析只展示了最后结果，仿真时间是1s，可以在第五步Steady-State Thermal分支中的Analysis Settings中设置。 5 瞬态仿真设置（该过程有点问题）用瞬态热分析模块看温度随时间的变化。在添加模块的主界面找到Transient Thermal模块，将其拖到Steady-State Thermal模块的第六行Solution项上，继承它的计算结果。效果应该是本文第一幅图中所表示的，Steady-State Thermal模块中的Solution指向Transient Thermal模块中的Setup。 打开Transient Thermal模块的Model项，可以看到在第五步Steady-State Thermal分支下多了个Transient Thermal。 第六步Transient Thermal分支。 Analysis Settings设置分析时间，分析步长。step end time设置分析的总时间，auto time setpping打开后可以设置步长，即多少秒计算一次，最低多少秒一步，最大多少秒一步。我的40G就是这里产生的，时间长，步长短，计算次数就多，计算结果的数据就多。 按我的意思应该可以直接计算了，但软件提示必须加个条件。也就是右键Transient Thermal后，在insert中必须选一个，我就把convection在这又加了一次，我觉得有问题的地方就在这里。 Solution分支与上面一样，Temperature的detail中可以选择任意时间的结果；Graph界面可以看曲线，温度还有下降趋势，应该把仿真时间调大再分析；播放按钮打开后能在模型界面看变化；Tabular Data界面可以把每一步的结果复制下来。 完！","categories":[{"name":"研究学习","slug":"研究学习","permalink":"http://xiiyue.gitee.io/categories/研究学习/"}],"tags":[{"name":"AnsysWorkbench","slug":"AnsysWorkbench","permalink":"http://xiiyue.gitee.io/tags/AnsysWorkbench/"}]},{"title":"Mathematica使用记录01-分式","slug":"20191023_Mathematica使用记录_01_分式","date":"2019-10-23T08:02:08.000Z","updated":"2019-10-30T13:32:23.025Z","comments":true,"path":"2019/10/23/20191023_Mathematica使用记录_01_分式/","link":"","permalink":"http://xiiyue.gitee.io/2019/10/23/20191023_Mathematica使用记录_01_分式/","excerpt":"&emsp;&emsp;做作业的时候，碰到了分子还可以分母不忍直视的分式，为了做反z变换，必须将其化为几个可以查表的分式，虽然我可以手算，但是嘛。。。","text":"&emsp;&emsp;做作业的时候，碰到了分子还可以分母不忍直视的分式，为了做反z变换，必须将其化为几个可以查表的分式，虽然我可以手算，但是嘛。。。 Apart-我裂开了&emsp;&emsp;函数原型：Apart[expr,var]&emsp;&emsp;expr就是你要处理的表达式&emsp;&emsp;var是可选的，可以不填，如果你的表达式中有多个变量，如x和y，填x则将y视为常数处理。 &emsp;&emsp;例： $\\frac{1}{x^4-2 x^2+1}$ &emsp;&emsp;在Mathematica中输入 Apart[1/(1-2*x^2+x^4)] &emsp;&emsp;shift 回车，输出结果如下图 &emsp;&emsp;如果想把分开的几个分式合并为一个呢？ Together-通分求和&emsp;&emsp;函数原型：Together[expr]&emsp;&emsp;expr就是你要处理的表达式&emsp;&emsp;在Mathematica中输入 Together[1/(4*(-1+x)^2)-1/(4*(-1+x))+1/(4*(1+x)^2)+1/(4*(1+x))] &emsp;&emsp;shift 回车，输出结果如下图 &emsp;&emsp;可以看到，结果并不是完全展开式。 &emsp;&emsp;所以$\\frac{1}{(x-1)^2 (x+1)^2}$跟$\\frac{1}{4 (x-1)^2}+\\frac{1}{4 (x+1)}+\\frac{1}{4 (x+1)^2}-\\frac{1}{4 (x-1)}$才是真正的一对？ &emsp;&emsp;如果想得到展开式呢？ Expand-展开&emsp;&emsp;函数原型：Expand[expr]&emsp;&emsp;expr就是你要处理的表达式&emsp;&emsp;在Mathematica中输入 Expand[(4*(-1+x)^2)] &emsp;&emsp;shift 回车，输出结果如下图 &emsp;&emsp;但是我想直接处理分式，应该选择Expand的扩展ExpandDenominator函数，即展开分母。如图 &emsp;&emsp;回过头处理刚才Together没搞定的多个分式。 &emsp;&emsp;第一次输入的是几个分式之和，它竟然是一个一个分开处理的。我只好先Together，再ExpandDenominator。 Factor-因式分解(没有裂开)&emsp;&emsp;函数原型：Factor[expr] &emsp;&emsp;在Mathematica中输入 Factor[1/(4*x^2-8*x+4)] &emsp;&emsp;输出结果如下图 &emsp;&emsp;另外，网上查Wolfram语法时发现用谷歌访问助手能“流畅”浏览，总比打不开好！","categories":[{"name":"研究学习","slug":"研究学习","permalink":"http://xiiyue.gitee.io/categories/研究学习/"}],"tags":[{"name":"Mathematic","slug":"Mathematic","permalink":"http://xiiyue.gitee.io/tags/Mathematic/"}]}]}